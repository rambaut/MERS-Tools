<html>
<head>
    <script src="js/jquery-2.0.3.min.js"></script>
    <script src="js/d3.min.js"></script>
    <script src="js/queue.min.js"></script>
    <style type="text/css">
        body{
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-weight:200;
            font-size:14px;
        }
        .axis path,.axis line {fill: none;stroke:#b6b6b6;shape-rendering: crispEdges;}
        /*.tick line{fill:none;stroke:none;}*/
        .tick text{fill:#999;}
        g.journal.active{cursor:pointer;}
        text.label{
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-weight:200;
            font-size:24px;
            cursor:pointer;
        }
        text.value{font-size:12px;font-weight:bold;}
    </style>
</head>
<body>

<script type="text/javascript">
var _MS_PER_DAY = 1000 * 60 * 60 * 24;


// a and b are javascript Date objects
function dateDiffInDays(a, b) {
    // Discard the time and time-zone information.
    var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

    return Math.floor((utc2 - utc1) / _MS_PER_DAY);
}


queue()
        .defer(d3.json, "data/cities.json")
        .defer(d3.csv, "data/cases.csv")
        .await(ready);


function ready(error, cityData, caseData) {
    if (error) return console.log("there was an error loading the data: " + error);


    // Various formatters.
    var formatNumber = d3.format(",d"),
            formatDate = d3.time.format("%Y-%m-%d"),
            formatPrettyDate = d3.time.format("%d %b"),
            formatMonth = d3.time.format("%b %Y");


    var cases = [];
    var clusters = {};

    var nestByDate = d3.nest()
            .key(function(d) { return d3.time.month(d.date); });

    // A little coercion, since the CSV is untyped.
    caseData.forEach(function(d, i) {
        d.index = i;

        if (d.onset !== null) {
            d.onset = formatDate.parse(d.onset);
        }

        if (d.hospitalized !== null) {
            d.hospitalized = formatDate.parse(d.hospitalized);
        }

        if (d.reported !== null) {
            d.reported = formatDate.parse(d.reported);
        }

        if (d.death !== null) {
            d.death = formatDate.parse(d.death);
            if (d.death !== null || d.outcome === 'fatal') {
                d.outcome = 2;
            } else {
                d.outcome = 1;
            }
        } else if (d.outcome === 'fatal') {
            d.outcome = 2;
        } else {
            d.outcome = 1;
        }

        d.date = d.onset;
        d.dateType = "onset";

        if (d.date === null) {
            d.date = d.hospitalized;
            d.dateType = "hospitalized";
        }
        if (d.date === null) {
            d.date = d.death;
            d.dateType = "death";

            if (d.date === null || d.reported < d.date) {
                d.date = d.reported;
                d.dateType = "reported";
            }
        }

        // convert age to number (with be NaN if parsing fails).
        d.age = +d.age;
        if (d.age === null || isNaN(d.age)) {
            d.age = -100;
        }

        if (d.gender === 'F') {
            d.genderCode = 1;
        } else if (d.gender === 'M') {
            d.genderCode = 2;
        } else {
            d.genderCode = 3;
        }

        if (d.date !== null) {
            cases.push(d);
        }

        if ((d.cluster !== null && d.cluster.length > 0) || d.secondary === "TRUE") {
            if (d.cluster === undefined || d.cluster === null || d.cluster.length === 0) {
                // if there is no cluster defined but is a secondary
                // create a new cluster label based on the number
                d.cluster = "#" + d.number;
            }

            if (d.cluster in clusters) {
                clusters[d.cluster].count ++;
            } else {
                clusters[d.cluster] = {
                    name: d.cluster,
                    count: 1
                };
            }
            d.cluster = clusters[d.cluster];
        } else {
            d.cluster = null;
        }

        d.comorbidity = (d.comorbidity === "TRUE" ? "existing" : (d.comorbidity === "FALSE" ? "none" : "unknown"));

        if (!(d.clinical === undefined)) {
            var clin = (d.clinical.split(" ")[0]);
            d.clinical = (clin === "clinical" || clin === "fatal" ? "severe/clinical" : (clin === "subclinical" ? "mild/subclinical" : "unknown"));
        }

        d.contact = (d.secondary === "TRUE" ? d.contact : "primary");
        d.contact = (d.contact === "contact" ? "unspecified contact" : d.contact);

        d.status = (d.suspected === "TRUE" ? "suspected" : "confirmed");

        var found = false;

        if (d.city.length > 0) {
            cityData.forEach(function(city) {
                if (d.city === city.name) {
                    d['city'] = city;
                    found = true;
                }
            });
            if (!found) console.log("City not found: " + d.city);
        }
        if (!found) d.city = null;

        found = false;

        // console.log(d.code + ": " + d.age + ", " + d.gender + ", " + d.country + " [" + d.dateType + "], " + d.secondary + ", " + d.cluster);
    });

    cases.sort(function(a,b) { return a.date.getTime() - b.date.getTime()});

    var lastDate = null;
    var lastOnset = null;

    cases.forEach(function(d, i) {
        if (lastDate !== null) {
            d.waitingTime = dateDiffInDays(lastDate, d.date);
        }
        lastDate = d.date;
        if (d.dateType === "onset" || d.dateType === "hospitalized") {
            if (lastOnset !== null) {
                d.waitingTimeOnset = dateDiffInDays(lastOnset, d.date);
            }
            lastOnset = d.date;
        }

        if (d.cluster !== null && d.cluster.count === 1) {
            d.cluster.count = 2;
        }
        //console.log(d.code + ": " + d.age + ", " + d.gender + ", " + d.country + " [" + d.dateType + "], "  + formatDate(d.date) + ", " + d.waitingTime + ", " + d.waitingTimeOnset );
    });

    var margin = {top: 30, right: 20, bottom: 30, left: 50},
            width = 600 - margin.left - margin.right,
            height = 270 - margin.top - margin.bottom;

    var parseDate = d3.time.format("%d-%b-%y").parse;

    var start_date = new Date("2012-01-01"),
            end_date = new Date("2013-01-01");

    var colors = d3.scale.category20b();

    var x = d3.time.scale().range([0, width]);
    var y = d3.scale.linear().range([height, 0]);

    var xAxis = d3.svg.axis()
            .scale(x)
            .orient("top")
            .ticks(5);

    var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left")
            .ticks(5);

    var valueline = d3.svg.line()
            .x(function(d) { return x(d.date); })
            .y(function(d) { return y(d.close); });

    var svg = d3.select("body")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    x.domain(d3.extent(cases, function(d) { return d.date; }));
    y.domain([0, d3.max(cases, function(d) { return d.age; })]);

    svg.append("path")      // Add the valueline path.
            .attr("d", valueline(cases));

    for (var j = 0; j < cases.length; j++) {
        var d = cases[j];

        var g = svg.append("g")
                .attr("class", "graph");

        var circles = g.selectAll("circle")
                .data(d['date'])
                .enter()
                .append("circle");

        var text = g.selectAll("text")
                .data(d['code'])
                .enter()
                .append("text");

//        var rScale = d3.scale.linear()
//                .domain([0, d3.max(d['date'], function(d) { return d[1]; })])
//                .range([2, 9]);

        circles
                .attr("cx", function(d, i) { return x(d.date); })
                .attr("cy", j + margin.top)
                .attr("r", 20)
//                .attr("r", function(d) { return rScale(d[1]); })
                .style("fill", function(d) { return colors(d.age); });

        text
                .attr("y", j + margin.top)
                .attr("x",function(d, i) { return x(d.date)-5; })
                .attr("class","value")
                .text(function(d){ return d[1]; })
                .style("fill", function(d) { return colors(j); })
                .style("display","none");

        g.append("text")
                .attr("y", j + margin.top)
                .attr("x",width+20)
                .attr("class","label")
                .text(d['code'])
                .style("fill", function(d) { return colors(j); });
        //			.on("mouseover", mouseover)
        //			.on("mouseout", mouseout);
    };

    svg.append("g")         // Add the X Axis
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

    svg.append("g")         // Add the Y Axis
            .attr("class", "y axis")
            .call(yAxis);


    function mouseover(p) {
        var g = d3.select(this).node().parentNode;
        d3.select(g).selectAll("circle").style("display","none");
        d3.select(g).selectAll("text.value").style("display","block");
    }

    function mouseout(p) {
        var g = d3.select(this).node().parentNode;
        d3.select(g).selectAll("circle").style("display","block");
        d3.select(g).selectAll("text.value").style("display","none");
    }
}

</script>

</body>
</html>
